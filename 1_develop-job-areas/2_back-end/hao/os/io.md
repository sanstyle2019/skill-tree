### IO
- 1.同步与异步
``` 
消息通信机制 主要针对Client接收响应的方式
同步就是调用者得到返回值才返回
异步就是调用者不关心返回值就直接返回，被调用者通过状态、通知来通知调用者，或者回调函数处理
    比如Node.js 线程池 事件驱动 异步
```
- 2.阻塞与非阻塞
``` 
程序在等待调用结果（消息，返回值）时的状态 主要针对Server处理请求的方式
阻塞就是调用结果返回之前，当前线程会被挂起(阻塞)，调用线程只有在得到结果之后才会返回，才会释放。
    调用线程就是工作线程，阻塞一定是同步的，这种性能太低，早已被淘汰
非阻塞就是在调用结果不能(立刻)得到结果之前，该调用线程不会阻塞当前线程 调用线程创建工作线程处理请求 立刻返回？
    涉及到调用线程和工作线程之前通信，看情况，可以同步，也可以异步  
    1.同步非阻塞 NIO 就是简单的IO多路复用(select poll) NIO的概念 CallThread(Selector) WorkThread
        Selector 要轮询 TCP连接请求 创建 WorkThread
    2.异步非阻塞 AIO(NIO2.0)
        客户端的TCP连接请求 都是OS完成了再通知 服务器应用去创建 WorkThread进行处理        
```
- 3.Question: 
``` 
什么是真正的异步？事件驱动算什么？
Netty使用NIO而不是AIO？
    Linux上的AIO的底层实现使用epoll,没有很好实现AIO，因此在性能上没有明显的优势。
    Netty整体架构是 reactor 模型 AIO是 proactor 模型 ？
    AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多。
    
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善


用IO操作中有阻塞来判断，5种IO模型中4种属于同步IO，
    分别是阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型。
    
阻塞IO模型：C：我买个这个东西？ S：暂时没有了，我赶紧进货，你在这先等一会，不要走！ C：好吧！
非阻塞IO模型：C：我买个这个东西？ S：暂时没有了，我赶紧进货，你先去玩一会，过会再来就有了！ C：好吧！

IO多路复用模型（select，poll，epoll）：和上面一样，只不过C太多了，这时候S就升级为Boss就负责管理，招几个S负责工作！
异步IO模型（POSIX的aio_系列函数）：

还是不理解？

阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；
    异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

首先要明白两个概念的不同：OS内核异步、进程线程异步、处理逻辑异步
OS内核异步是 操作系统内核来处理IO，不用进程线程去处理。真正的异步、狭义的异步。
进程线程异步是 多进程处理、多线程处理(NIO里的多路复用技术) 主要是对应阻塞还是非阻塞、这一个都是真正的同步，不是真正意义的异步
处理逻辑异步是 处理逻辑异步化，不关心 底层是 同步还是异步、阻塞还是非阻塞
    比如，在高并发下的下单逻辑，通过MQ来实现异步化，提升性能，然后直接返回下单中，请刷新；下单成功之后，待支付，又通过MQ来异步化...
    当然从 底层IO方式 的角度考虑肯定是非阻塞的方式，至于是同步非阻塞还是异步非阻塞，这个就要看底层IO采用什么方式了。
    
同步
    阻塞：淘汰
    非阻塞：NIO多路复用(select,poll,epoll,各有优缺点)
异步    
    非阻塞：AIO
        
```

- 4.Netty(Java)
``` 
Netty是一个 异步事件驱动 的 网络应用程序 框架 用于快速开发可维护的高性能协议服务器和客户端。

```
- 5.Tomcat(Java)
``` 

```
- 6.Spring(Java)
``` 

```