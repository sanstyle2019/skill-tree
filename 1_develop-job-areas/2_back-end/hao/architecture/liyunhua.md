[TOC]
## 从零开始学架构（李运华）
``` 
软件架构指软件系统的顶层结构。
架构设计的主要目的是为了解决软件系统复杂度带来的问题。
```

### 基础概念
- 系统与子系统
- 模块与组件
``` 
划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。
```
- 框架与架构
``` 
框架关注的是“规范”，架构关注的是“结构”。
框架的英文是 Framework，架构的英文是 Architecture。
```

### 历史背景
- 机器语言（1940 年之前）
- 汇编语言（20 世纪 40 年代）
- 高级语言（20 世纪 50 年代）
- 第一次软件危机与结构化程序设计（20 世纪 60 年代~20 世纪 70 年代）
``` 
第一次软件危机的根源在于软件的“逻辑”变得非常复杂。
```
- 第二次软件危机与面向对象（20 世纪 80 年代）
``` 
第二次软件危机主要体现在软件的“扩展”变得非常复杂。
面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，
后来的 Java、C# 把面向对象推向了新的高峰。
到现在为止，面向对象已经成为了主流的开发思想。
```
- 软件架构的历史背景
``` 
软件架构的出现有其历史必然性。
20 世纪 60 年代第一次软件危机引出了“结构化编程”，创造了“模块”概念；
20 世纪 80 年代第二次软件危机引出了“面向对象编程”，创造了“对象”概念；
到了 20 世纪 90 年代“软件架构”开始流行，创造了“组件”概念。
我们可以看到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，
差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。
```

### 架构要考虑的点
- 性能
``` 
MySQL, Nginx
```
- 可扩展性
- 高可用
``` 
数据存储高可靠，设计MySQL跨机房同步方案（一主多备跨机房）
```
- 安全性
``` 
Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。
```
- 成本

#### 高性能
- 单机复杂度
``` 
计算机内部复杂度最关键的地方就是操作系统。
操作系统和性能最相关的就是进程和线程。
为了进一步提升性能，人们发明了“进程”，用进程来对应一个任务，每个任务都有自己独立的
内存空间，进程间互不相关，由操作系统来进行调度。
此时的 CPU 还没有多核和多线程的概念，为了达到多进程并行运行的目的，采取了分时的方式，
即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令。
虽然从操作系统和 CPU 的角度来说还是串行处理的，但是由于 CPU 的处理速度很快，
从用户的角度来看，感觉是多进程在并行处理。
多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，
但从用户的角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得更加灵活高效。
否则如果两个任务运行过程中不能通信，只能是 A 任务将结果写到存储，B 任务再从存储读取进行处理，不仅效率低，而且任务设计更加复杂。
为了解决这个问题，进程间通信的各种方式被设计出来了，
包括管道、消息队列、信号量、共享存储等。
多进程让多任务能够并行处理任务，但本身还有缺点，单个进程内部只能串行处理，
为了解决这个问题，人们又发明了线程，线程是进程内部的子任务，但这些子任务都共享同一份进程数据。
为了保证数据的正确性，又发明了互斥锁机制。
有了多线程后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。

操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点。

举一个最简单的例子：
    Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，
这些系统都实现了高性能，但内部实现差异却很大。
```
- 集群的复杂度
``` 
1.任务分配（水平扩展）
    这个分配器可能是硬件网络设备（例如，F5、交换机等），
    可能是软件网络设备（例如，LVS），
    也可能是负载均衡软件（例如，Nginx、HAProxy）
    任务分配器需要增加分配算法。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。
    如果按照服务器的负载进行分配，则业务服务器还要能够上报自己的状态给任务分配器。
    
2.任务分解（垂直拆分）
```

#### 高可用
``` 
系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。

系统统的高可用方案五花八门，但万变不离其宗，本质上都是通过“冗余”来实现高可用。

高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。
```
- 计算高可用
``` 

```
